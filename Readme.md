1) What is the difference between var, let, and const?
Answer: Var, let, and const are used to declare variables but differ in scope, re-declaration, and reassignment. var is function-scoped, hoisted, and allows re-declaration and reassignment, which can cause unexpected bugs. let is block-scoped, cannot be re-declared in the same scope, but can be reassigned, making it useful for variables that change. const is also block-scoped but cannot be reassigned, ideal for constants. However, objects and arrays declared with const can still be modified internally. Modern best practice is to avoid var and use let for mutable values and const for immutable bindings.
2) What is the difference between map(), forEach(), and filter()?
Answer: map(), forEach(), and filter() are array methods but serve different purposes. map() creates a new array by applying a function to each element, useful when I want to transform data. forEach() simply loops through each element and executes a function, but it does not return a new array—it’s mainly for side effects like logging or updating external variables. filter() creates a new array with only the elements that pass a given condition, ideal for selecting specific data. In short: use map() for transformation, forEach() for iteration, and filter() for selection.
3) What are arrow functions in ES6?
Answer: Arrow functions, introduced in ES6, provide a shorter syntax for writing functions in JavaScript. They use the => symbol instead of the traditional function keyword. Arrow functions are often more concise and are especially useful for inline callbacks. Unlike normal functions, they do not have their own this, arguments, or super. Instead, they inherit this from their surrounding scope (lexical scoping). This makes them ideal for use inside methods, event listeners, and array methods. However, they cannot be used as constructors.
4) How does destructuring assignment work in ES6?
Answer: In ES6, destructuring assignment allows me to unpack values from arrays or properties from objects into separate variables in a concise way.I can also set default values, skip elements, or nest destructuring. This feature makes code cleaner and avoids repetitive property access, especially when working with function parameters or API responses.
5) Explain template literals in ES6. How are they different from string concatenation?
Answer: In ES6, template literals are a new way to work with strings using backticks (``) instead of quotes. They support string interpolation, allowing me to embed variables or expressions inside ${} without using the + operator. Difference from string concatenation: Traditional concatenation uses + and can be messy, while template literals are cleaner, more readable, support multi-line text, and allow embedding directly.